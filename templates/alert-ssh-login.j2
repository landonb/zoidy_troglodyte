#!/bin/bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Project: https://github.com/landonb/zoidy_troglodyte#üßî
# License: MIT

# *** DO NOT EDIT THIS FILE ***
#
# This file is generated by an Ansible play. See:
#
#   zoidy_troglodyte/templates/alert-ssh-login.j2
#
# The destination is a system file:
#
#   /root/bin/alert-ssh-login
#
# NOTE: After reinstalling this script or resetting alert-ssh-login, test it works:
#
#         ansible $(hostname) -m ping
#
#         # Or:
#         ansible $(hostname) -m ping -vvv
#
# NOTE: If you screw up this file and Ansible starts to fail on UNREACHABLE!, try:
#
#         sudo sh -c "printf '%b' '#!/bin/bash\nexit 0\n' > /root/bin/alert-ssh-login"
#
#         # MEH: Resetting alert-ssh-login takes a moment/minute to take effect.
#         # - I tried `sudo service sshd restart` but doesn't help.
#         #   Not sure what's up.
#         # So just keep trying for a minute until the ping starts to work.
#         ansible $(hostname) -m ping -vvv

# +++++++++++++++++++++++++++++++++++++++++++++++

# TRYME: Some test snips (try setting myhost.lan and IPs to real values):
#
#   sudo tail -F /var/log/syslog /var/log/ufw.log /var/log/auth.log
#
#   sudo TRACE=true PAM_USER=myuser PAM_RHOST=myhost.lan /root/bin/alert-ssh-login
#   sudo TRACE=true PAM_USER=myuser PAM_RHOST=myhost.lan PAM_TYPE=close_session /root/bin/alert-ssh-login
#   sudo TRACE=true PAM_USER=myuser SSH_CONNECTION="192.168.11.22 123 456 789" /root/bin/alert-ssh-login
#   sudo TRACE=true PAM_USER=myuser SSH_CONNECTION="abc1:de23:f456::7a8 123 456 789" /root/bin/alert-ssh-login

# +++++++++++++++++++++++++++++++++++++++++++++++

# YOU: Setup postfix and create /home/user/.forward if you want
#      to have sent emails forwarded to, say, Gmail. See:
#         zoidy_home-fries/tasks/email-gmail-postfix.yml
SEND_EMAIL_TO="{{ ansible_env.LOGNAME }}@$(hostname)"
SEND_EMAIL_FROM="$(basename $0)@$(hostname)"

# YOU: Specify list of known hostnames and IP addresses you trust.
#      The script will ignore those events and not send alert emails
#      about them. Look in your private `group_vars/zoidy_troglodyte`
#      for:
#         zoidy_troglodyte_pam_sshd_known_hosts
#         zoidy_troglodyte_pam_sshd_known_ips
# - Note that for some connections, like from *Password Store* app,
#   $PAM_RHOST contains local LAN hostname, but $SSH_CONNECTION is unset.
# - But for other connections, e.g., `ssh somehost`, $SSH_CONNECTION
#   contains IP, but $PAM_RHOST is empty.
#
export KNOWN_HOSTS=()
{% for known_host in zoidy_troglodyte_pam_sshd_known_hosts %}
KNOWN_HOSTS+=("{{ known_host }}")
{% endfor %}
#
export KNOWN_IPS=()
{% for known_ip in zoidy_troglodyte_pam_sshd_known_ips %}
KNOWN_IPS+=("{{ known_ip }}")
{% endfor %}

# +++++++++++++++++++++++++++++++++++++++++++++++

TRACE=${TRACE:-false}
# TRACE=true

# +++++++++++++++++++++++++++++++++++++++++++++++

element_in () {
  local pattern
  local element="$1"
  shift
  # So that globbing works, e.g., [[ 192.168.11.123 == 192.168.11.* ]]
  # put pattern on right (Bash only honors '*' to right of operator);
  # and avoid quotes.
  for pattern; do [[ ${element} == ${pattern} ]] && return 0; done
  return 1
}

# ***

reset_script_environs () {
  ALERT_REASONS=""
  ENEMY_ADDY=""
  ENEMY_HOST=""
  ENEMY_USER=""
}

# ***

set_who_they_are () {
  # PAM is used on some SSH connections (e.g., via *Password Store* app)
  # but not for `ssh` itself (e.g., `ssh myhost`).
  #
  # The environs are sparse coming through PAM, e.g.,
  #   LANG=en_US.UTF-8
  #   PAM_TYPE=open_session
  #   XDG_SESSION_ID=886
  #   PAM_RHOST=hostname.lan
  #   PAM_USER=user
  #   PAM_TTY=ssh
  #   PWD=/
  #   SSH_AUTH_INFO_0=publickey ssh-ed25519 XXXXXXXXX....
  #   SHLVL=1
  #   PAM_SERVICE=sshd
  #   DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
  #   XDG_RUNTIME_DIR=/run/user/1000
  #   PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
  #   _=/usr/bin/env

  reset_script_environs

  set_enemy_user_from_environs
  set_enemy_host_from_environs
  set_enemy_addy_from_environs

  [ -n "${ENEMY_ADDY}" ] || resolve_enemy_addy_from_pam_rhost
  [ -n "${ENEMY_HOST}" ] || resolve_enemy_host_from_enemy_addy
}

# ***

set_enemy_user_from_environs () {
  # Note that when PAM_USER is set, neither is USER or LOGNAME.
  [ -n "${PAM_USER}" ] && ENEMY_USER="${PAM_USER}" || ENEMY_USER="${LOGNAME}"
}

set_enemy_host_from_environs () {
  # PAM_RHOST is, e.g., "myhost.lan".
  if [ -n "${PAM_RHOST}" ]; then
    ENEMY_HOST="${PAM_RHOST}"
  fi
}

set_enemy_addy_from_environs () {
  # SSH_CONNECTION is, e.g., "192.168.11.22 58800 192.168.11.66 22"
  #                          (client ip     port  server ip     port).
  # - Use Bash `%% *` to capture only the first word (client IP).
  if [ -n "${SSH_CONNECTION}" ]; then
    ENEMY_ADDY="${SSH_CONNECTION%% *}"
  fi
}

# ***

# 2022-01-25: I know two ways to resolve a hostname to an IP address.
#
# - You can use `ping` to determine an IP address, e.g.:
#
#     $ ping -c1 pixel-5a.lan
#     PING pixel-5a.lan (192.168.11.123) 56(84) bytes of data.
#     64 bytes from Pixel-5a.lan (192.168.11.123): icmp_seq=1 ttl=64 time=80.1 ms
#
#     --- pixel-5a.lan ping statistics ---
#     1 packets transmitted, 1 received, 0% packet loss, time 0ms
#     rtt min/avg/max/mdev = 80.108/80.108/80.108/0.000 ms
#
#   - Note that `ping` prints the IPv6 when available, e.g.:
#
#       $ ping -c1 myhost.lan | head -1
#       PING myhost.lan(myhost.lan (abc1:de23:f456::7a8)) 56 data bytes
#
#     If we wanted, we could tell `ping` to print the IPv4 address, e.g.:
#
#       $ ping -4 -c1 myhost.lan | head -1
#       PING myhost.lan (192.168.11.456) 56(84) bytes of data.
#
#     But we might as well be future-proff and prefer IPv6.
#
#   - NOTE: If using `ping` to resolve the host, be sure to list the IPv6
#     address in the skip-list, if the host has one. (Though if `nslookup`
#     is used, list both IPv4 and IPv6 addresses; see following comment.)
#
# - You can also use `nslookup` to determine an IP address, e.g.:
#
#     $ nslookup myhost.lan
#     Server:  127.0.0.53
#     Address: 127.0.0.53#53
#
#     Non-authoritative answer:
#     Name: myhost.lan
#     Address: 192.168.11.456
#     Name: myhost.lan
#     Address: abc1:de23:f456::7a8
#
#   - You can restrict to the IPv6 address only:
#
#       $ nslookup -q=AAAA myhost.lan
#
#     - Though I didn't see an IPv4-only option.
#
#       - This option prints both IPv4 and IPv6 addresses:
#
#         $ nslookup -q=AAA myhost.lan
#
#   - Because the author is unsure if `nslookup` always prints the IPv6
#     address last, be sure to list both IPv4 and IPv6 addresses in the
#     skip-list.
#
# - The author includes both methods in case things ever change and we need
#   to tweak the logic here. Also I like writing pipeline commands, yay fun.
#
#   - Currently, this script uses `nslookup` to query the name server,
#     rather than deducing it with ping. This seems like the more logical
#     call to make. But the outcome from either function should be the same.
resolve_enemy_addy_from_pam_rhost () {
  resolve_ip_ping () {
    # - Use ping to resolve the remote host name.
    #   - Print IPv4 (`-4`), because the format differs from IPv6,
    #     and this pipeline isn't clever enough to process both formats.
    #     - E.g., an IPv4 format could look like:
    #         PING pixel-5a.lan (192.168.11.123) 56(84) bytes of data.
    #       Whereas an IPv6 format could look like:
    #         PING myhost.lan(myhost.lan (abc1:de23:f456::7a8)) 56 data bytes
    #   - Restrict number of pings with `-c1`.
    # - Use grep to pick out the IP address.
    #   - Restrict total grep hits with `-m1`.
    #   - Use Perl-like regex (`-P`) to access two features:
    #     - Lookbehind (`\K`), and
    #     - Non-greedy matching (`.*?`).
    #   - Print -o/--only-matching parts of a matching line.
    #   - Note that -o on its own doesn't let you specify non-greedy matching
    #     (using `.*?`), e.g.,
    #       $ ‚Ä¶ | grep -m1 -o '(.*)'
    #     prints
    #       (192.168.11.123) 56(84)
    #     but
    #       $ ‚Ä¶ | grep -m1 -o '(.*?)'
    #     prints nothing.
    #   - Using Perl-like regex:
    #     - Specify lookbehind (\K) to remove leading the parenthesis ('(');
    #     - Specify non-greedy matching (the '?' in `.*?`) so the matching
    #       stops at end of the IP, e.g., the greedy match:
    #         $ ‚Ä¶ | ping -c1 pixel-5a.lan | head -1 | grep -m1 -Po '\(\K.*(?=\))'
    #       might return:
    #         192.168.11.123) 56(84
    #       as opposed to what a non-greedy match might return, e.g.,:
    #         192.168.11.123
    # - The two "(parenthetical) (values)" are output on separate lines.
    #   - Pick just the first value with a final `| head -1`.
    ping -4 -c1 "${PAM_RHOST}" | head -1 | grep -m1 -Po '\(\K.*?(?=\))' | head -1
  }

  resolve_ip_nslookup () {
    # - Use `sed` to print the 'Name:' line through the 'Address:' line (`/p`),
    #   otherwise delete (suppress from output) all the other lines (`/d`).
    # - Take the second of these two lines (`tail -1`) and, similar to `ping` logic,
    #   use Perl-like regex (`-P`) for lookbehind (`\K`) and print -o/--only-matching parts.
    # - Note: If nslookup reports IPv6, `tail -1` might return second Address,
    #   which for me is IPv6. You could use `head -2 | tail -1` to get first
    #   Address, which may or may not always be IPv4. Better bet is to specify
    #   both IPv4 and IPv6 addresses in your skip-list.
    nslookup "${PAM_RHOST}" | sed -E -e '/^Name:/,/^Address:/p' -e '/.*/d' | tail -1 | grep -Po ': \K.*'
  }

  # - Set the ENEMY_ADDY aka PAM_RIPADDY IP address.
  [ -n "${PAM_RHOST}" ] && ENEMY_ADDY="$(resolve_ip_nslookup)"
  [ -n "${ENEMY_ADDY}" ] || ENEMY_ADDY='[unknown IP!]'
}

# ***

UNKNOWN_HOST='[unknown host!]'

# E.g.,
#   $ host 192.168.11.456
#   456.11.168.192.in-addr.arpa domain name pointer myhost.lan.
resolve_enemy_host_from_enemy_addy () {
  resolve_hostname_from_host_cmd () {
    host "${ENEMY_ADDY}" | grep -Po ' domain name pointer \K.*(?=\.)'
  }
  ENEMY_HOST="$(resolve_hostname_from_host_cmd)"
  [ -n "${ENEMY_HOST}" ] || ENEMY_HOST="${UNKNOWN_HOST}"
}

# ***

print_environment () {
  # ***

  cat <<EOF

<pre>
\$(env)
======
$(env)
EOF

  # ***

  cat <<EOF

script vars
===========
ENEMY_ADDY="${ENEMY_ADDY}"
ENEMY_HOST="${ENEMY_HOST}"
ENEMY_USER="${ENEMY_USER}"
LOGNAME="${LOGNAME}"
PAM_USER="${PAM_USER}"
PAM_RHOST="${PAM_RHOST}"
SSH_CONNECTION="${SSH_CONNECTION}"
EOF

  # ***

  echo
  echo "KNOWN_HOSTS"
  echo "==========="

  # Note: Bash array lookup uses the same syntax as Jinja {# comments #}.
  # - If you don't escape such syntax, because the Bash lookup doesn't use
  #   a closing delimiter, Ansible will exit with the following message:
  #     AnsibleError: template error while templating string: Missing end of comment tag.
  # - To avoid the problem, start the Bash array lookup with a {{ 'literal' }},
  #   e.g., `{{ '${#' }} KNOWN_HOSTS[@]}`, or make the whole thing a literal.
  #     https://jinja.palletsprojects.com/en/3.0.x/templates/#escaping
  for (( idx = 0; idx < {{ '${#KNOWN_HOSTS[@]}' }}; idx++ )); do  # BREADCRUMB: Bash for loop syntax.
    echo "KNOWN_HOSTS[$idx]=${KNOWN_HOSTS[$idx]}"
  done

  # ***

  echo
  echo "KNOWN_IPS"
  echo "========="

  for (( idx = 0; idx < {{ '${#KNOWN_IPS[@]}' }}; idx++ )); do  # BREADCRUMB: Bash for loop syntax.
    echo "KNOWN_IPS[$idx]=${KNOWN_IPS[$idx]}"
  done

  # ***

  cat <<EOF
</pre>

Alert reason(s): ${ALERT_REASONS}
EOF
}

# ***

print_user_and_reason () {
  local reason_suffix=""
  [ -n "${ALERT_REASONS}" ] && reason_suffix=" [${ALERT_REASONS}]"

  printf '%s' "${ENEMY_USER}@$(hostname)${reason_suffix}"
}

# ***

add_alert_reason () {
  local alert_reason="$1"

  [ -n "${ALERT_REASONS}" ] && ALERT_REASONS="${ALERT_REASONS}, "

  ALERT_REASONS="${ALERT_REASONS}${alert_reason}"
}

# ***
alert_confused () {
  add_alert_reason "cannot check unknown host"

  local subject="ALERT: Untrusted logon from *Unknown Host* (${ENEMY_ADDY}) to $(print_user_and_reason)"

  $TRACE && echo "EMAIL: alert_confused: ${subject}"

  logger -t ssh-wrapper "alert-ssh-login: ${subject}"

  mailx \
    -r "${SEND_EMAIL_FROM}" \
    -a 'Content-Type: text/html' \
    -s "${subject}" \
    "${SEND_EMAIL_TO}" \
    <<EOF
<p>
<strong>So confused!</strong> Date: $(date)
</p>

<p>
The User <em>‚Äú${ENEMY_USER}‚Äù</em>
from Untrusted IP ‚Äî <strong><u>${ENEMY_ADDY}</u></strong> ‚Äî
coming through PAM
<strong>with Indiscernible hostname</strong>
has logged on @$(hostname)‚Åâ
</p>

<p>
<b>ARE YOU SAFE‚Åâ</b>
</p>

$(print_environment)
EOF
}

# ***

alert_breached () {
  local subject="ALERT: Untrusted logon from ‚Äú${ENEMY_HOST}‚Äù (${ENEMY_ADDY}) to $(print_user_and_reason)"

  $TRACE && echo "EMAIL: alert_breached: ${subject}"

  logger -t ssh-wrapper "alert-ssh-login: ${subject}"

  mailx \
    -r "${SEND_EMAIL_FROM}" \
    -a 'Content-Type: text/html' \
    -s "${subject}" \
    "${SEND_EMAIL_TO}" \
    <<EOF
<p>
<strong>Breached!</strong> Date: $(date)
</p>

<p>
The User <em>‚Äú${ENEMY_USER}‚Äù</em>
from Untrusted host ‚Äî <strong><u>${ENEMY_HOST}</u></strong> (${ENEMY_ADDY}) ‚Äî
has logged on @$(hostname)‚Äº
</p>

<p>
<b>ARE YOU SAFE?</b>
</p>

$(print_environment)
EOF
}

# ***

set_alert_if_unknown_host_or_addy () {
  if ! element_in "${ENEMY_HOST}" "${KNOWN_HOSTS[@]}"; then
    add_alert_reason "unlisted hostname"
  fi

  if ! element_in "${ENEMY_ADDY}" "${KNOWN_IPS[@]}"; then
    add_alert_reason "unlisted ip-addry"
  fi
}

# ***

alert_breached_unless_skip_listed () {
  set_alert_if_unknown_host_or_addy

  if [ -n "${ALERT_REASONS}" ]; then
    alert_breached
  else
    local subject="Trusted user from ‚Äú${ENEMY_HOST}‚Äù (${ENEMY_ADDY}) logged on $(print_user_and_reason)"

    $TRACE && echo "${subject}"

    logger -t ssh-wrapper "alert-ssh-login: ${subject}"
  fi
}

# ***

alert_loggedoff () {
  local subject="ALERT: Enemy from ‚Äú${ENEMY_HOST}‚Äù (${ENEMY_ADDY}) logged off $(print_user_and_reason)"

  $TRACE && echo "EMAIL: alert_loggedoff: ${subject}"

  logger -t ssh-wrapper "alert-ssh-login: ${subject}"

  mailx \
    -r "${SEND_EMAIL_FROM}" \
    -a 'Content-Type: text/html' \
    -s "${subject}" \
    "${SEND_EMAIL_TO}" \
    <<EOF
<p>
<strong>They‚Äôre gone!</strong> Date: $(date)
</p>

<p>
The User <em>‚Äú${ENEMY_USER}‚Äù</em>
from Untrusted host ‚Äî <strong><u>${ENEMY_HOST}</u></strong> (${ENEMY_ADDY}) ‚Äî
has logged off @$(hostname)!!
</p>

<p>
<b>ARE YOU SAFE?</b>
</p>

$(print_environment)
EOF
}

check_closing () {
  # (lb): I saw close_session occur 1m07s after open_session, even though
  # user was still logged on/had not logged off. Whatever. I don't expect
  # this code to ever run!! #zero-breaches
  [ "${PAM_TYPE}" = 'close_session' ] || return 1

  set_alert_if_unknown_host_or_addy

  if [ -n "${ALERT_REASONS}" ]; then
    alert_loggedoff
  else
    local subject="Trusted user from ‚Äú${ENEMY_HOST}‚Äù (${ENEMY_ADDY}) logged off $(print_user_and_reason)"

    $TRACE && echo "${subject}"

    logger -t ssh-wrapper "alert-ssh-login: ${subject}"
  fi
}

# ***

main () {
  set_who_they_are

  # If PAM specifies 'close_session', alert the session is over unless verified.
  check_closing && return

  # This script is normally called by /etc/pam.d/sshd, and we can suss IP.
  # - But if you run the script manually, and not through an SSH session, and
  #   you don't call, e.g., `PAM_USER=someuser /root/bin/alert-ssh-login`,
  #   then the host might not be determinable. This is always an alert.
  [ "${ENEMY_HOST}" = "${UNKNOWN_HOST}" ] && alert_confused && return

  # For all other events -- PAM session not being closed, and IP determined --
  # verify remote host and IP, and email/alert unless both values skip-listed.
  alert_breached_unless_skip_listed
}

main "$@"

